<h1><a href="#8-6-将-map-的键值对调" name="8-6-将-map-的键值对调"></a>8.6 将 map 的键值对调</h1>
<p>这里对调是指调换 key 和 value。如果 map 的值类型可以作为 key 且所有的 value 是唯一的，那么通过下面的方法可以简单的做到键值对调。</p>
<p>示例 8.7 <a href="examples/chapter_8/invert_map.go">invert_map.go</a>：</p>
<pre><code class="go">package main
import (
	&quot;fmt&quot;
)

var (
	barVal = map[string]int{&quot;alpha&quot;: 34, &quot;bravo&quot;: 56, &quot;charlie&quot;: 23,
							&quot;delta&quot;: 87, &quot;echo&quot;: 56, &quot;foxtrot&quot;: 12,
							&quot;golf&quot;: 34, &quot;hotel&quot;: 16, &quot;indio&quot;: 87,
							&quot;juliet&quot;: 65, &quot;kili&quot;: 43, &quot;lima&quot;: 98}
)

func main() {
	invMap := make(map[int]string, len(barVal))
	for k, v := range barVal {
		invMap[v] = k
	}
	fmt.Println(&quot;inverted:&quot;)
	for k, v := range invMap {
		fmt.Printf(&quot;Key: %v, Value: %v / &quot;, k, v)
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>inverted:
Key: 34, Value: golf / Key: 23, Value: charlie / Key: 16, Value: hotel / Key: 87, Value: delta / Key: 98, Value: lima / Key: 12, Value: foxtrot / Key: 43, Value: kili / Key: 56, Value: bravo / Key: 65, Value: juliet /
</code></pre>
<p>如果原始 value 值不唯一那这么做肯定会出问题；这种情况下不会报错，但是当遇到不唯一的 key 时应当直接停止对调，且此时对调后的 map 很可能没有包含原 map 的所有键值对！一种解决方法就是仔细检查唯一性并且使用多值 map，比如使用 <code>map[int][]string</code> 类型。</p>
<p><strong>练习 8.2</strong></p>
<p>构造一个将英文饮料名映射为法语（或者任意你的母语）的集合；先打印所有的饮料，然后打印原名和翻译后的名字。接下来按照英文名排序后再打印出来。</p>
<h2><a href="#链接" name="链接"></a>链接</h2>
<ul>
  <li><a href="directory.html">目录</a></li>
  <li>上一节：<a href="08.5.html">map 的排序</a></li>
  <li>下一章：<a href="09.0.html">包（package）</a></li>
</ul>